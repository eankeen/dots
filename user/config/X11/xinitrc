#!/bin/sh

set -e

xrdb -merge "$XDG_CONFIG_HOME/X11/xresources"

# attempt to create an error file; abort if we cannot
errorFile=$HOME/.xsession-errors
if (umask 077 && touch "$errorFile") 2> /dev/null && [ -w "$errorFile" ] && [ ! -L "$errorFile" ]; then
	chmod 600 "$errorFile"
elif errorFile=$(tempfile 2> /dev/null); then
	if ! ln -sf "$errorFile" "${tempDir:=/tmp}/xsession-$USER"; then
		echo "Warning: unable to symlink '$tempDir/xsession-$USER' to '$errorFile'. Look for session log / errors in '$tempDir/xsession-$USER'"
		exit 1
	fi
else
	echo "Error: Unable to create X session log/error file"
	exit 1
fi

exec >> "$errorFile" 2>&1

echo "----- $Xsession: X session started for $LOGNAME at $(date) -----"



# FILE
if [ -z "$DBUS_SESSION_BUS_ADDRESS" ] && [ -n "$XDG_RUNTIME_DIR" ] && \
		[ "$XDG_RUNTIME_DIR" = "/run/user/`id -u`" ] && \
		[ -S "$XDG_RUNTIME_DIR/bus" ]; then
	# We are under systemd-logind or something remarkably similar, and
	# a user-session socket has already been set up.
	#
	# Be nice to non-libdbus, non-sd-bus implementations by using
	# that as the session bus address in the environment. The check for
	# XDG_RUNTIME_DIR = "/run/user/`id -u`" is because we know that
	# form of the address, from systemd-logind, doesn't need escaping,
	# whereas arbitrary addresses might.
	DBUS_SESSION_BUS_ADDRESS="unix:path=$XDG_RUNTIME_DIR/bus"
	export DBUS_SESSION_BUS_ADDRESS
fi


if [ -x "/usr/bin/dbus-update-activation-environment" ]; then
	# tell dbus-daemon --session (and systemd --user, if running) to put a minimal
	# subset of the Xsession's environment in activated services' environments

	dbus-update-activation-environment --verbose --systemd \
		DBUS_SESSION_BUS_ADDRESS DISPLAY XAUTHORITY
fi


export QT_ACCESSIBILITY=1
if [ -x "/usr/bin/dbus-update-activation-environment" ]; then
	dbus-update-activation-environment --verbose --systemd QT_ACCESSIBILITY
fi


# If xhost is installed, use it to give access to the X server for any process from
# the same user on the local host. Unlike other uses of xhost, this is safe since the
# kernel can check the actual owner of the calling process.
if type xhost >/dev/null 2>&1; then
	xhost +si:localuser:$(id -un) || :
fi


xsetroot -xcf /usr/share/icons/breeze_cursors/cursors/left_ptr 4
xrdb $XDG_CONFIG_HOME/X11/xresources

. ~/scripts/temp/x.sh
quatrenary

nitrogen --restore

#âž¤ SSH_AUTH_SOCK="$(gpgconf --list-dirs agent-ssh-socket)" git push

#gpg-agent --daemon || true
#unset SSH_AGENT_PID
#if [ "${gnupg_SSH_AUTH_SOCK_by:-0}" -ne $$ ]; then
#	export SSH_AUTH_SOCK="$(gpgconf --list-dirs agent-ssh-socket)"
#fi

~/config/polybar/launch.sh || true

#xset +fp /usr/share/fonts/misc
#xset +fp ~/.fonts
#xset fp rehash
# Sync clipboards (some bad decisions really stick around...)
#autocutsel -fork
#autocutsel -selection PRIMARY -fork

exec i3

exit 0
